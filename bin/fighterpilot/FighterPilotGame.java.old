package fighterpilot;

import gameEvent.AI;
import physics.Collidable;
import graphics.SpriteSheet;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

import javax.swing.JFrame;
import javax.swing.JPanel;

import level.*;
import physics.Physics;


/**This is the GameLogic Portion of the program, and also where the painting of the screen happens
 * 
 * @author Brady
 *
 */
public class FighterPilotGame extends JPanel {//can extend Canvas, but there is a terrible flicker, so don't extend Canvas.

    private static final long serialVersionUID = 1L;//So Java Cannot Complain

    public static final int WIDTH = 800;//640, 1440, 800
    public static final int HEIGHT = 600;//480, 720, 600
    public static final int SCALE = 1;//1
    public static final String NAME = "FighterPilot2TestGame";

    public static final int SPEED = 1;//Wait time for all threads

    private JFrame frame;

    private Camera cam;

    //Game-specific stuff
    private Level lvl;

    private boolean moveUP,moveDN,moveLF,moveRT,rst,follow,bound = true;
    private int[] pointToFollow = new int[2];
    private int[] boundaries = new int[4];//{xmin,ymin,xmax,ymax}

    //Might be useful for implementing Multiplayer in the future
    private Player[] players = new Player[1]; 

    //This is for different GameModes, mainly to implement title screens, loading screns, cutscenes, as well as different rules and such reguarding a gamemode.
    private enum GameMode{
	TitleIntro, 		//The Intro before the Title 
	TitleScreen, 		//The Actual Title Screen
	ShooterLevelIntro,	//The Intro before the ShooterLevel
	ShooterLevel,		//ShooterLevel is being played
	ShooterLevelSuccess,	//End of the ShooterLevel, when finished
	ShooterLevelFail,	//End of the ShooterLevel, if failure.

    }
    private boolean paused = false;//If game is paused.

    /**Default Constructor, acts as the Initializer for the Game
     * 
     */
    public FighterPilotGame() {//Init Routine for Game

	setMinimumSize(new Dimension(WIDTH*SCALE, HEIGHT*SCALE));
	setMaximumSize(new Dimension(WIDTH*SCALE, HEIGHT*SCALE));
	setPreferredSize(new Dimension(WIDTH*SCALE, HEIGHT*SCALE));

	frame = new JFrame(NAME);
	frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	frame.setLayout(new BorderLayout());

	frame.add(this, BorderLayout.CENTER);
	frame.pack();

	frame.setResizable(false);//false
	frame.setLocationRelativeTo(null);
	frame.setVisible(true);

	cam = new Camera(WIDTH*SCALE, HEIGHT*SCALE, 256); //Buffer will be 32

	//Game Specific Stuff========================================
	frame.setFocusable(true);//must be true to capture keystrokes
	frame.addKeyListener(new AL());
	moveUP = false;
	moveDN = false;
	moveLF = false;
	moveRT = false;
	rst = false;
	follow = false;
	pointToFollow[0] = 0;
	pointToFollow[1] = 0;
	bound = true;
	boundaries[0] = 0;
	boundaries[1] = 0;
	boundaries[2] = 0;
	boundaries[3] = 0;

	//Implementation of Multiplayer: have all players in this array, then add them to Level. If they go out of Level, readd them back into a chunk.
	//Player[] players = new Player[1];
	//players[0] = new Player("Player1", 0, 0, 0.0, 0.0);



    }

    /**This Method actually starts the Game
     * 
     */
    public void start(){
	/*BGLayer[] b = new BGLayer[1];//Global Background
	b[0] = new BGLayer(1,"FighterPilotImages/Background.png",0.0,0.0,true,true);

	BGLayer[] f = new BGLayer[0];//Global Foreground (not used here)
	//f[0] = new BGLayer(2,"BG1.png");

	lvl = new Level("New Level",0,4,16,b,f,new SpriteSheet(SpriteSheet.TRANSPARENT));

	SpriteLayer sl1 = new SpriteLayer(0);
	sl1.sprites.add(new Enemy("Hello",0,0,4.0, 4.0));//Speed Doesn't exist
	players[0] = new Player("Player", 0, 0, 0.0, 0.0);
	sl1.sprites.add(players[0]);
	lvl.chunks[0][0].layers.add(sl1);

	SpriteLayer sl2 = new SpriteLayer(0);
	sl2.sprites.add(new Enemy("HelloAgain",0,0,4.0, 4.0));//Speed Doesn't exist
	sl2.sprites.add(new Enemy("Test2", 0, 0, 0.0, 0.0));
	lvl.chunks[1][3].layers.add(sl2);

	SpriteLayer sl3 = new SpriteLayer(0);
	sl3.sprites.add(new Enemy("ItsMe",0,0,4.0, 4.0));//Speed Doesn't exist
	sl3.sprites.add(new Enemy("Resting?", 0, 0, 0.0, 0.0));
	lvl.chunks[3][4].layers.add(sl3);

	SpriteLayer sl4 = new SpriteLayer(0);
	sl4.sprites.add(new Enemy("Hello",0,0,4.0, 4.0));//Speed Doesn't exist
	sl4.sprites.add(new Enemy("Nope", 0, 0, 0.0, 0.0));
	lvl.chunks[1][6].layers.add(sl4);

	SpriteLayer sl5 = new SpriteLayer(0);
	sl5.sprites.add(new Enemy("Hello",0,0,4.0, 4.0));//Speed Doesn't exist
	sl5.sprites.add(new Enemy("Nope", 0, 0, 0.0, 0.0));
	lvl.chunks[2][8].layers.add(sl5);*/

	lvl = this.randomLevel(4, 16, 100, 4);
	//lvl = this.randomLevelTest(32, 32, 1);//4, 16, 1

	follow = true;

	//Set the Camera Starting point, or it just defaults to 0, 0
	//cam.setOrigin((players[0].loc.x * lvl.s.getSpriteSize() * lvl.chunks[0][0].getBlockSize()[0]) + (lvl) , y);

	bound = true;
	boundaries[0] = 0;
	boundaries[1] = 0;
	boundaries[2] = lvl.chunks[0].length * lvl.chunks[0][0].getBlockSize()[0] * lvl.s.getSpriteSize();
	boundaries[3] = lvl.chunks.length * lvl.chunks[0][0].getBlockSize()[1] * lvl.s.getSpriteSize();

	/*//Start all Threads
		DoAI da = new DoAI();
		(new Thread(da)).start();

		DoControls dc = new DoControls();
		(new Thread(dc)).start();

		DoPhysics dp = new DoPhysics();
		(new Thread(dp)).start();
	 */
	DoGameLoop dgl = new DoGameLoop();
	(new Thread(dgl)).start();

	while(true){
	    repaint();
	}


    }
    /**This generates a Random Level
     * 
     * @param rowChunks how many rows of chunks to generate
     * @param ColChunks how many cols of Chunks to generate
     * @param enemyProb PRobability of enemies appearing
     * @param maxEnemies Maximum number of enemies that can be in a chunk
     * @return the Randomly Generated Level
     */
    public Level randomLevel(int rowChunks, int colChunks, int enemyProb, int maxEnemies){
	System.out.println("Generating Level...|");

	Random rand = new Random();

	BGLayer[] bg = new BGLayer[1];//Global Background
	bg[0] = new BGLayer(1,"FighterPilotImages/Background.png",0.0,0.0,true,true);//FighterPilotImages/Background.png

	BGLayer[] fg = new BGLayer[0];//Global Foreground


	Level level = new Level("RandomGen", -1, rowChunks, colChunks,bg ,fg,new SpriteSheet(SpriteSheet.TRANSPARENT));

	for(int i = 0; i < rowChunks; i++) {

	    for(int j = 0; j < colChunks; j++){

		boolean empty = true;

		SpriteLayer sLayer = new SpriteLayer(0);

		if(i == 0 && j == 0){//Adds Player
		    players[0] = new Player("Player1", 0, 0, 4.0, 4.0);
		    sLayer.sprites.add(players[0]);
		}

		for(int k = 0; k < maxEnemies; k++){
		    if(rand.nextBoolean()){
			empty = false;
			sLayer.sprites.add(new Enemy("RandGen",0,0,rand.nextDouble()*8,rand.nextDouble()*8));//Adds Enemy
		    }
		}

		if(!empty){
		    //System.out.println("Adding SpriteLayer|" + sLayer);
		    level.chunks[i][j].layers.add(sLayer);//Since this is a new Level, there should not be a Spritelayer, so we don't really need to check for one, as that would be stupid
		}



		//Code to add random Blocks
	    }
	}

	//level.manageChunks();

	return level;
    }
    /**Randomly Generates a Level full of Enemies
     * 
     * @param rows Rows of Chunks in Level
     * @param cols Cols of Chunks in Level
     * @param enemiesPerChunk Total Enemies that will be placed in Level
     * @return Randomly Generated Level
     */
    public Level randomLevelTest(int rows, int cols, int enemiesPerChunk){

	BGLayer[] bg = new BGLayer[1];//Global Background
	bg[0] = new BGLayer(1,"BG0.png",0.25,0.25,true,true);//FighterPilotImages/Xevious_area_all.png
	//bg[1] = new BGLayer(2, "FighterPilotImages/TestClouds.png", 0.75, 0.75, true, true);

	BGLayer[] fg = new BGLayer[0];//Global Foreground

	Level level = new Level("RandomLevel.Test", -1, rows, cols, bg, fg, new SpriteSheet(SpriteSheet.TRANSPARENT));

	for(int i = 0; i < level.chunks.length; i++){
	    for(int j = 0; j < level.chunks[0].length; j++){

		SpriteLayer sLayer = new SpriteLayer(0);

		for(int k = 0; k < enemiesPerChunk; k++){
		    sLayer.sprites.add(new Enemy("RandGen", 0, 0, 4.0, 4.0));

		}

		if(i == rows - 1 && j == cols - 1){
		    players[0] = new Player("PlayerRandGen", 0, 0, 0.0, 0.0);
		    sLayer.sprites.add(players[0]);
		}

		//System.out.println(sLayer);
		level.chunks[i][j].layers.add(sLayer);
		sLayer = null;
	    }

	}

	level.manageChunks();
	return level;
    }

    /**This paints the Level
     * 
     */
    public void paint(Graphics g) {
	super.paint(g);
	Graphics2D g2d = (Graphics2D) g;

	if(lvl == null){
	    System.out.println("Loading Level...");
	    return;
	}

	/***********************************************************************************************************************************************
	 * Paints level-global BG
	 ***********************************************************************************************************************************************/
	//Right now, Scroll Factors over 1.0 and below 0.0 cause weird things to happen.

	for(int i = 0; i < lvl.bg.length; i++){//BGLayer to render

	    //System.out.println(((int) ((cam.getXmin() - cam.getBuffer() - lvl.bg[i].getBufferedImage().getWidth()) * (lvl.bg[i].scrollFactorX)) / lvl.bg[i].getBufferedImage().getWidth()) * lvl.bg[i].getBufferedImage().getWidth() + " " + ((int) ((cam.getXmax() + cam.getBuffer() + lvl.bg[i].getBufferedImage().getWidth()) * (/*1 + */lvl.bg[i].scrollFactorX)) / lvl.bg[i].getBufferedImage().getWidth()) * lvl.bg[i].getBufferedImage().getWidth() + " | " + ((int) ((cam.getYmin() - cam.getBuffer() - lvl.bg[i].getBufferedImage().getHeight()) * (lvl.bg[i].scrollFactorY)) / lvl.bg[i].getBufferedImage().getHeight()) * lvl.bg[i].getBufferedImage().getHeight() + " " + ((int) ((cam.getYmax() + cam.getBuffer() + lvl.bg[i].getBufferedImage().getHeight()) * (/*1 + */lvl.bg[i].scrollFactorY)) / lvl.bg[i].getBufferedImage().getHeight()) * lvl.bg[i].getBufferedImage().getHeight());

	    for(int j = ((int) ((cam.getXmin() - cam.getBuffer() - lvl.bg[i].getBufferedImage().getWidth()) * (lvl.bg[i].scrollFactorX)) / lvl.bg[i].getBufferedImage().getWidth()) * lvl.bg[i].getBufferedImage().getWidth(); j < ((int) ((cam.getXmax() + cam.getBuffer() + lvl.bg[i].getBufferedImage().getWidth()) * (1 + lvl.bg[i].scrollFactorX)) / lvl.bg[i].getBufferedImage().getWidth()) * lvl.bg[i].getBufferedImage().getWidth(); j = j + lvl.bg[i].getBufferedImage().getWidth()){
		for(int k = ((int) ((cam.getYmin() - cam.getBuffer() - lvl.bg[i].getBufferedImage().getHeight()) * (lvl.bg[i].scrollFactorY)) / lvl.bg[i].getBufferedImage().getHeight()) * lvl.bg[i].getBufferedImage().getHeight(); k < ((int) ((cam.getYmax() + cam.getBuffer() + lvl.bg[i].getBufferedImage().getHeight()) * (1 + lvl.bg[i].scrollFactorY)) / lvl.bg[i].getBufferedImage().getHeight()) * lvl.bg[i].getBufferedImage().getHeight(); k = k + lvl.bg[i].getBufferedImage().getHeight()){
		    g2d.drawImage(lvl.bg[i].getBufferedImage() , (int) (j - cam.getXmin() * lvl.bg[i].scrollFactorX) , (int) (k - cam.getYmin() * lvl.bg[i].scrollFactorY),null);
		    if(!lvl.bg[i].isYRepeating()){//Ends if not repeating. Done so that it draws the first image then will stop
			k = cam.getYmax() + cam.getBuffer();
		    }
		}
		if(!lvl.bg[i].isXRepeating()){//Ends if not repeating
		    j = cam.getXmax() + cam.getBuffer();
		}
	    }
	}

	/*

		//Creates Rendering Plan in the form of a NumberTree so as to prevent bad rendering like what happened with the old render method.

		DualNumberTree renderPlan = new DualNumberTree();

		for(int i = 0; i < lvl.chunks.length; i++) {
		    for(int j = 0; j < lvl.chunks[0].length; j++) {

			if(cam.isInside(j * lvl.s.getSpriteSize() * lvl.chunks[i][j].getBlockSize()[0] ,  i * lvl.s.getSpriteSize() * lvl.chunks[i][j].getBlockSize()[1] )) {

			    lvl.chunks[i][j].isActive = true;

			    for(int k = 0; k < lvl.chunks[i][j].layers.size(); k++){//For every Layer that the Chunk has, it will be added to the DualNumberTree
				renderPlan.addData(k, i, j);
			    }

			}else{
			    lvl.chunks[i][j].isActive = false;
			}
		    }
		}



		//This Following Code Paints the Chunks.

		for(int currentLayerNumber : renderPlan.getAllBranchIds()){//Current Layer Number to Render
		    	for(int i = 0; i < renderPlan.getBranch(currentLayerNumber).length; i++){//Current Branch of IDs
	    			if(lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber) instanceof BlockLayer) {
				    	for(int l=0; l < ((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks.length; l++){//row
	    					for(int m=0; m < ((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks[0].length; m++){//col

	    					    	if(cam.isInside((m * lvl.s.getSpriteSize())	+ (renderPlan.getBranch(currentLayerNumber)[i][1] * lvl.s.getSpriteSize() * ((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks.length), (l * lvl.s.getSpriteSize()) + (renderPlan.getBranch(currentLayerNumber)[i][0] * lvl.s.getSpriteSize() * ((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks[0].length))) {							

	    							g2d.drawImage(lvl.s.getBufferedImage(((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks[l][m].id), (m*lvl.s.getSpriteSize()) + (renderPlan.getBranch(currentLayerNumber)[i][1]*lvl.s.getSpriteSize()*((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks.length) - cam.getXmin(), (l*lvl.s.getSpriteSize()) + (renderPlan.getBranch(currentLayerNumber)[i][0]*lvl.s.getSpriteSize()*((BlockLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).blocks[0].length) - cam.getYmin(), null);
							}

						}
					}
				}else if(lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber) instanceof SpriteLayer){

				    for(int spt=0;spt<( (SpriteLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).sprites.size();spt++){
					if(cam.isInside((int) ((renderPlan.getBranch(currentLayerNumber)[i][1] * lvl.s.getSpriteSize() * lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][1]][renderPlan.getBranch(currentLayerNumber)[i][1]].getBlockSize()[0]) + ( (double) lvl.s.getSpriteSize() * ( (SpriteLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).sprites.get(spt).loc.x) ), (int) ( (renderPlan.getBranch(currentLayerNumber)[i][1] * lvl.s.getSpriteSize() * lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][1]][renderPlan.getBranch(currentLayerNumber)[i][1]].getBlockSize()[1]) + ( (double) lvl.s.getSpriteSize() * ( (SpriteLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).sprites.get(spt).loc.y) ) ) ) {
					    g2d.drawImage(( (SpriteLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).sprites.get(spt).getImage(),  (int)((renderPlan.getBranch(currentLayerNumber)[i][1]*lvl.s.getSpriteSize()*lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].getBlockSize()[0]) + ((double)lvl.s.getSpriteSize()*( (SpriteLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).sprites.get(spt).loc.x)) - cam.getXmin(),  (int)((renderPlan.getBranch(currentLayerNumber)[i][0]*lvl.s.getSpriteSize()*lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].getBlockSize()[1]) + ((double)lvl.s.getSpriteSize()*( (SpriteLayer) lvl.chunks[renderPlan.getBranch(currentLayerNumber)[i][0]][renderPlan.getBranch(currentLayerNumber)[i][1]].layers.get(currentLayerNumber)).sprites.get(spt).loc.y)) - cam.getYmin(), null);


					}
				    }


				}

	    			//Add Code for BGLayer


			}



		}*/


	/**********************************************************************************************************************************************
	 * Paints the Chunks
	 ***********************************************************************************************************************************************/

	for(int i=0; i < lvl.chunks.length ;i++){//row
	    for(int j=0; j < lvl.chunks[0].length; j++){//col

		//Makes sure chunk is inside Viewing Area before rendering
		if(cam.isInside(  j * lvl.s.getSpriteSize() * lvl.chunks[i][j].getBlockSize()[0] ,  i * lvl.s.getSpriteSize() * lvl.chunks[i][j].getBlockSize()[1] )){
		    lvl.chunks[i][j].isActive = true;

		    //Layer
		    for(int k=0; k < lvl.chunks[i][j].layers.size();k++){
			if(lvl.chunks[i][j].layers.get(k) instanceof BlockLayer){//==========================================================================================================

			    //Draws Blocks
			    BlockLayer blayer = (BlockLayer) lvl.chunks[i][j].layers.get(k);//Had to do this to make it work

			    for(int l=0; l < blayer.blocks.length; l++){//row
				for(int m=0; m < blayer.blocks[0].length;m++){//col

				    //Draws Blocks, checks to make sure inside bounds
				    //Computes Block size:: <Current Row "l">*<BlockSize> + <Current Chunk Row "i">*<BlockSize>
				    if(cam.isInside((m*lvl.s.getSpriteSize()) + (j*lvl.s.getSpriteSize()*blayer.blocks.length), (l*lvl.s.getSpriteSize()) + (i*lvl.s.getSpriteSize()*blayer.blocks[0].length))){							

					g2d.drawImage(lvl.s.getBufferedImage(blayer.blocks[l][m].id), (m*lvl.s.getSpriteSize()) + (j*lvl.s.getSpriteSize()*blayer.blocks.length) - cam.getXmin(), (l*lvl.s.getSpriteSize()) + (i*lvl.s.getSpriteSize()*blayer.blocks[0].length) - cam.getYmin(), null);
				    }
				}	
			    }	
			}else if(lvl.chunks[i][j].layers.get(k) instanceof SpriteLayer){

			    //Draws Sprites
			    SpriteLayer splyr = (SpriteLayer) lvl.chunks[i][j].layers.get(k);

			    for(int spt=0;spt<splyr.sprites.size();spt++){

				//CameraFollowMode code
				if(follow && splyr.sprites.get(spt) instanceof Player){
				    pointToFollow[0] = (int)((j*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[0]) + ((double)lvl.s.getSpriteSize()*splyr.sprites.get(spt).loc.x));
				    pointToFollow[1] = (int)((i*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[1]) + ((double)lvl.s.getSpriteSize()*splyr.sprites.get(spt).loc.y));
				}


				if(cam.isInside((int)((j*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[0]) + ((double)lvl.s.getSpriteSize()*splyr.sprites.get(spt).loc.x)),(int)((i*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[1]) + ((double)lvl.s.getSpriteSize()*splyr.sprites.get(spt).loc.y)))){
				    g2d.drawImage(splyr.sprites.get(spt).getImage(), (int)((j*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[0]) + ((double)lvl.s.getSpriteSize()*splyr.sprites.get(spt).loc.x)) - cam.getXmin(),  (int)((i*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[1]) + ((double)lvl.s.getSpriteSize()*splyr.sprites.get(spt).loc.y)) - cam.getYmin(), null);
				}
			    }
			}else if(lvl.chunks[i][j].layers.get(k) instanceof BGLayer){

			    //Draws BG, takes care of positioning
			    BGLayer bglyr = (BGLayer) lvl.chunks[i][j].layers.get(k);

			    //Does not render before origin
			    for(int bglj = (j*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[0]); bglj<cam.getXmax()+cam.getBuffer(); bglj=bglj+bglyr.getBufferedImage().getWidth()){
				for(int bglk = (i*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[1]); bglk<cam.getYmax()+cam.getBuffer(); bglk=bglk+bglyr.getBufferedImage().getHeight()){
				    if(cam.isInside((j*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[0]), (i*lvl.s.getSpriteSize()*lvl.chunks[i][j].getBlockSize()[1]))){
					g2d.drawImage(bglyr.getBufferedImage(),bglj-cam.getXmin(),bglk-cam.getYmin(),null);

					if(!bglyr.isYRepeating()){//Ends if not repeating
					    bglk = cam.getYmax()+cam.getBuffer();
					}
				    }
				}
				if(!bglyr.isXRepeating()){//Ends if not repeating
				    bglj = cam.getXmax()+cam.getBuffer();
				}
			    }
			}else{
			    System.out.println("WARN:: unknown Layer type at " + k);
			}
		    }
		}else{
		    lvl.chunks[i][j].isActive = false;
		    //If Chunk is not in Camera (is being displayed on the screen, it is inactive
		}
	    }
	}

	/*********************
	 * Paints level-global FG
	 ***********************/
	for(int i=0;i<lvl.fg.length;i++){

	    //Does not render before origin
	    for(int j=0;j<cam.getXmax()+cam.getBuffer(); j=j+lvl.fg[i].getBufferedImage().getWidth()){

		for(int k=0;k<cam.getYmax()+cam.getBuffer();k=k+lvl.fg[i].getBufferedImage().getHeight()){

		    g2d.drawImage(lvl.fg[i].getBufferedImage(),j-cam.getXmin(),k-cam.getYmin(),null);

		    if(!lvl.fg[i].isYRepeating()){//Ends if not repeating
			k = cam.getYmax()+cam.getBuffer();
		    }
		}
		if(!lvl.fg[i].isXRepeating()){//Ends if not repeating
		    j = cam.getXmax()+cam.getBuffer();
		}
	    }
	}

	g2d.drawString("Resolution::" + WIDTH*SCALE + "x" + HEIGHT*SCALE, 10, 10);
	g2d.drawString("CameraPosition::" + "xmin: " + cam.getXmin() + " xmax: " + cam.getXmax() + " ymin: " + cam.getYmin() + " ymax: " + cam.getYmax(), 10,20);	
    }







    //Contains all Camera Vars
    /**This Class contains all variables for a "Camera" to prevent unnecessary chunks from loading and being rendered
     * 
     * @author Brady
     *
     */
    private class Camera{

	private int xsize, ysize;
	private int buffer;

	private int xmin,xmax,ymin,ymax;

	/**Constructor for Camera.
	 * 
	 * @param x Size of X axis in Pixels
	 * @param y Size of Y Axis in Pixels
	 * @param b Size of Buffer in Pixels
	 */
	public Camera(int x, int y, int b){

	    xsize = x;
	    ysize = y;

	    xmin = 0;
	    xmax = xsize;
	    ymin = 0;
	    ymax = ysize;

	    buffer = b;
	}

	/**Checks to see if the given point is inside of the Screen
	 * 
	 * @param x X Coordinate of point
	 * @param y Y Coordinate of point
	 * @return true if the points are inside of the camera area
	 */
	public boolean isInside(int x, int y) {

	    return x >= xmin-buffer && x <= xmax+buffer && y >= ymin-buffer && y <= ymax+buffer;
	}

	/**Moves the Camera area by increasing the X and Y axis by specified number of pixels.
	 * 
	 * @param x Moves X axis in Pixels
	 * @param y Moves Y axis in Pixels
	 */
	public void move(int x, int y){

	    xmin += x;
	    xmax += x;

	    ymin += y;
	    ymax += y;
	}

	/**Moves the Camera to the specified point
	 * 
	 * @param x X Coordinate to set Camera to
	 * @param y Y Coordinate to set Camera to
	 */
	public void setOrigin(int x, int y){

	    xmin = x;
	    xmax = x + xsize;

	    ymin = y;
	    ymax = y + ysize;

	}

	/**Returns the XMin
	 * 
	 * @return Minimum of X Axis
	 */
	public int getXmin(){
	    return xmin;
	}

	/**Returns xMax
	 * 
	 * @return Maximum of X Axis
	 */
	public int getXmax(){
	    return xmax;
	}

	/**Returns yMin
	 * 
	 * @return Minimum of Y Axis
	 */
	public int getYmin(){
	    return ymin;
	}

	/**Returns YMax
	 * 
	 * @return Maximum of Y Axis
	 */
	public int getYmax(){
	    return ymax;
	}

	/**Returns the Buffer Space
	 * 
	 * @return Buffer Space in Pixels
	 */
	public int getBuffer(){
	    return buffer;
	}

    }

    /**This Takes Keyboard Input.
     * <p>
     * May be able to expand and use custom inputs using an array and have each index represent a certain keystroke, or something
     * @TODO Add Pause and Reset Buttons. Pause pauses all AI and movement. Reset reloads the level
     * 	
     * @author Brady
     *
     */
    private class AL extends KeyAdapter {

	/**Do this when Key is pressed
	 * 
	 */
	public void keyPressed(KeyEvent e){

	    int key = e.getKeyCode();

	    if(key == KeyEvent.VK_UP){
		moveUP = true;
	    } 
	    if(key == KeyEvent.VK_DOWN){
		moveDN = true;
	    }
	    if(key == KeyEvent.VK_LEFT){
		moveLF = true;
	    }
	    if(key == KeyEvent.VK_RIGHT){
		moveRT = true;
	    }
	    if(key == KeyEvent.VK_SPACE){
		rst = true;
	    }
	    if(key == KeyEvent.VK_C){

		//follow = true;
	    }

	    //Player Controls
	    if(key == KeyEvent.VK_W){
		players[0].moveUp = true;
	    }
	    if(key == KeyEvent.VK_A){
		players[0].moveLeft = true;
	    }
	    if(key == KeyEvent.VK_S){
		players[0].moveDown = true;
	    }
	    if(key == KeyEvent.VK_D){
		players[0].moveRight = true;
	    }
	    if(key == KeyEvent.VK_E){
		players[0].fire = true;
	    }


	}
	/**Do This when key is released
	 * 
	 */
	public void keyReleased(KeyEvent e) {

	    int key = e.getKeyCode();

	    if(key == KeyEvent.VK_UP){
		moveUP = false;
	    } 

	    if(key == KeyEvent.VK_DOWN ){
		moveDN = false;
	    }
	    if(key == KeyEvent.VK_LEFT){
		moveLF = false;
	    }
	    if(key == KeyEvent.VK_RIGHT){
		moveRT = false;
	    }
	    if(key == KeyEvent.VK_SPACE){
		rst = false;
	    }
	    if(key == KeyEvent.VK_C){
		if(follow){
		    follow = false;
		} else{
		    follow = true;
		}

	    }

	    //Player Controls
	    if(key == KeyEvent.VK_W){
		players[0].moveUp = false;
	    }
	    if(key == KeyEvent.VK_A){
		players[0].moveLeft = false;
	    }
	    if(key == KeyEvent.VK_S){
		players[0].moveDown = false;
	    }
	    if(key == KeyEvent.VK_D){
		players[0].moveRight = false;
	    }
	    if(key == KeyEvent.VK_E){
		players[0].fire = false;
	    }

	}
    }


    /**Makes for an easy way to get KeyValues and also change keyBindings
     * 
     * @author Brady
     *
     */
    private class keyBinder{

	//Keys for players are stored in groups of 6: Movement up, down, left, and right a fire button and an extra button.

	private int[][] keyStore;


	/**Creates new KeyBinder Object.
	 * 
	 */
	public keyBinder(){
	    //Inits class
	    keyStore = new int[players.length + 1][6];//Have enough buttons for the Players plus camera

	}

	/**Creates new KeyBinder Object
	 * 
	 * @param numberPlayers Number of players (Camera Controls are added)
	 */
	public keyBinder(int numberPlayers){
	    //Inits class
	    keyStore = new int[numberPlayers + 1][6];//Have enough buttons for the Players plus camera
	}

	/**Interactive Method: Maps all keys using a terminal interface.
	 * 
	 */
	public void mapKeys(){
	    //Maps all keys.

	}

	/**Maps one key
	 * 
	 * @param entity Player/Entity to map keys of
	 * @param button Button to map
	 * @param newValue New button Value to map to
	 */
	public void mapKey(int entity, int button, int newValue){
	    keyStore[entity][button] = newValue;
	}

	/**Gets a key
	 * 
	 * @param entity Entity to get key from
	 * @param button Button to get keyValue from
	 * @return New KeyValue
	 */
	public int getKey(int entity, int button){
	    return keyStore[entity][button];
	}
    }

    /**This class does AI methods and is also responsible for the calls to Chunk Management
     * 
     * @author Brady
     *
     */
    /*private class DoAI implements Runnable{

	public void run(){

	    //System.out.println("DoAI() Works.");

	    while(true){

		lvl.manageChunks();

		try {
		    Thread.sleep(SPEED);
		} catch (InterruptedException e) {
		    e.printStackTrace();
		}

		for(int i=0;i<lvl.chunks.length;i++){
		    for(int j=0;j<lvl.chunks[0].length;j++){

			if(lvl.chunks[i][j].isActive){
			    //This is for UpdateChunks, bu It needs work, as it doesn't really work right now

			    //This obviously doesn't work..... but how should I make it work???
			    //Need to change location of Sprites in neighboring chunks
			    Chunk[][] temp = new Chunk[3][3];
			    //System.out.println("Now on Chunk " + i + " " + j);
			    for(int m = i - 1; m < i + 1; m++){
				for(int n = j - 1; n < j + 1; n++){
				    if(m >= 0 && n >= 0 && m < lvl.chunks.length && n < lvl.chunks[0].length ){
					temp[m-i+1][n-j+1] = lvl.chunks[m][n];
				    }else{
					temp[m-i+1][n-j+1] = null;
				    }
				}
			    }

			    for(int k=0; k<lvl.chunks[i][j].layers.size();k++){

				if(lvl.chunks[i][j].layers.get(k) instanceof SpriteLayer){

				    for(int l=0;l < ((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.size();l++){

					if(((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l) instanceof AI){
					    //Does AI Methods, including methods that may add other Sprites/Blocks/Backgrounds

					    //((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).updateChunk(temp);//Old Method. Will not work anymore


					    ((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).updateChunk(temp);
					    ((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).doAI();

					    Sprite tmp = ((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).getChildren();
					    if(tmp != null) {
						//System.out.println("NewChild:" + tmp);
						((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.add(tmp);

					    }

					}
				    }	
				}
			    }
			}
		    }
		}
	    }
	}
    }*/

    /**Does Controls
     * 
     * @author Brady
     *
     */
    /*private class DoControls implements Runnable{

	public void run(){

	    System.out.println("DoControls Works.");

	    while(true){

		try {
		    Thread.sleep(SPEED);
		} catch (InterruptedException e) {
		    e.printStackTrace();
		}

		if(moveUP){
		    cam.move(0, -1);
		}
		if(moveDN){
		    cam.move(0, 1);
		}
		if(moveLF){
		    cam.move(-1, 0);
		}
		if(moveRT){
		    cam.move(1, 0);
		}
		if(rst){
		    cam.setOrigin(0, 0);
		}

		//DoPlayerControls


	    }
	}
    }*/

    /*private class DoPhysics implements Runnable{

	public void run(){

	    System.out.println("DoPhysics Works.");

	    while(true){

		try {
		    Thread.sleep(SPEED*2);
		} catch (InterruptedException e) {
		    e.printStackTrace();
		}

		for(int i = 0; i < lvl.chunks.length; i++){//row
		    for(int j = 0; j < lvl.chunks[0].length; j++){//col
			for(int k = 0; k < lvl.chunks[i][j].layers.size(); k++){//layers
			    if(lvl.chunks[i][j].layers.get(k) instanceof SpriteLayer){//Sprites
				for(int l = 0; l < ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.size(); l++){
				    if(((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l) instanceof Physics){
					((Physics)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l)).doPhysics();
					System.out.println("Physics done at Sprite: " + ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l));
				    }
				}

			    }

			}
		    }
		}

	    }
	}
    }*/


    private class DoGameLoop implements Runnable {

	public void run(){

	    while(true){
		try {
		    Thread.sleep(SPEED);
		} catch (InterruptedException e) {
		    e.printStackTrace();
		}

		lvl.manageChunks();
		doAI();
		//doPhysics();
		doControls();
		doCamera();
		doCollision();

		//System.out.println("===POOP===LOOP===");

	    }
	}
    }




    /**Does AI Method. Gets around Concurrency Issues
     * 
     */
    private void doAI(){
	for(int i=0;i<lvl.chunks.length;i++){
	    for(int j=0;j<lvl.chunks[0].length;j++){

		if(lvl.chunks[i][j].isActive && lvl.chunks[i][j].hasSpriteLayer()){
		    //This is for UpdateChunk, gives 3x3 block of Chunks to Sprites to use for AI

		    //Has an issue where the row2, col2 chunks are Null. 
		    Chunk[][] temp = new Chunk[3][3];
		    //System.out.println("Now on Chunk " + i + " " + j);
		    //Stops at 2 because I am dumb, or something. Duh!
		    for(int m = i - 1; m < i + 2; m++){
			for(int n = j - 1; n < j + 2; n++){
			    if(m >= 0 && n >= 0 && m < lvl.chunks.length && n < lvl.chunks[0].length){
				temp[m-i+1][n-j+1] = lvl.chunks[m][n];
				//System.out.println("NormChunk in updateChunk: " + (m-i+1) + " " + (n-j+1));
			    }else{
				temp[m-i+1][n-j+1] = null;
				//System.out.println("NullChunk in updateChunk: " + (m-i+1) + " " + (n-j+1));
			    }
			}
		    }

		    for(int k=0; k<lvl.chunks[i][j].layers.size();k++){

			if(lvl.chunks[i][j].layers.get(k) instanceof SpriteLayer){

			    /**
			     * @TODO
			     * Clean up code - Since I can get access to a spritelayer without the use of another new object, it is pointless and probably slows down the program. CLEANITUP!!
			     * 
			     * 
			     */
			    for(int l=0;l < ((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.size();l++){

				if(((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l) instanceof AI){
				    //Does AI Methods, including methods that may add other Sprites/Blocks/Backgrounds

				    //((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).updateChunk(temp);//Old Method. Will not work anymore

				    ((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).updateChunk(temp);
				    ((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).doAI();

				    Sprite tmp = ((AI)((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.get(l)).getChildren();
				    if(tmp != null) {
					//System.out.println("NewChild:" + tmp);
					((SpriteLayer) lvl.chunks[i][j].layers.get(k)).sprites.add(tmp);
				    }

				}
			    }	
			}
		    }
		}
	    }
	}
    }

    //These methods are meant to help reduce the concurrency issues present in the design that uses multiple threads
    /**Handles Controls
     * 
     */
    private void doControls(){
	

	//DoPlayerControls
    }
    /**Does Camera Movement
     * 
     */
    private void doCamera(){
	if(moveUP){
	    cam.move(0, -1);
	}
	if(moveDN){
	    cam.move(0, 1);
	}
	if(moveLF){
	    cam.move(-1, 0);
	}
	if(moveRT){
	    cam.move(1, 0);
	}
	if(rst){
	    cam.setOrigin(0, 0);
	}
	if(follow){//Follow Player Camera Mode

	    if(!cam.isInside(pointToFollow[0], pointToFollow[1])){

		if(cam.getXmin() < pointToFollow[0]){
		    cam.move(10, 0);
		}
		if(cam.getXmax() > pointToFollow[0]){
		    cam.move(-10, 0);
		}
		if(cam.getYmin() < pointToFollow[1]){
		    cam.move(0, 10);
		}
		if(cam.getYmax() > pointToFollow[1]){
		    cam.move(0, -10);
		}
	    }else{
		//Is inside Camera

		if(pointToFollow[0] - cam.getXmin() < WIDTH/2){
		    cam.move(-1, 0);
		}
		if(pointToFollow[0] - cam.getXmin() > WIDTH/2){
		    cam.move(1, 0);
		}
		if(pointToFollow[1] - cam.getYmin() < HEIGHT/2){
		    cam.move(0, -1);
		}
		if(pointToFollow[1] - cam.getYmin() > HEIGHT/2){
		    cam.move(0, 1);
		}

	    }
	}

	if(bound){//Do Camera Boundaries
	    if(cam.xmin < boundaries[0]){
		//System.out.println("Cam out of Bounds: Xmin");
		cam.setOrigin(boundaries[0], cam.getYmin());
	    }
	    if(cam.ymin < boundaries[1]){
		//System.out.println("Cam out of Bounds: Ymin");
		cam.setOrigin(cam.getXmin(), boundaries[1]);
	    }
	    if(cam.xmax > boundaries[2]){
		//System.out.println("Cam out of Bounds: Xmax");
		cam.setOrigin(boundaries[2] - WIDTH, cam.getYmin());
	    }
	    if(cam.ymax > boundaries[3]){
		//System.out.println("Cam out of Bounds: Ymax");
		cam.setOrigin(cam.getXmin(), boundaries[3] - HEIGHT);
	    }
	}

    }
    /**Does Physics
     * 
     */
    private void doPhysics(){
	for(int i = 0; i < lvl.chunks.length; i++){//row
	    for(int j = 0; j < lvl.chunks[0].length; j++){//col
		for(int k = 0; k < lvl.chunks[i][j].layers.size(); k++){//layers
		    if(lvl.chunks[i][j].layers.get(k) instanceof SpriteLayer){//Sprites
			for(int l = 0; l < ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.size(); l++){
			    if(((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l) instanceof Physics){
				((Physics)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l)).doPhysics();
				System.out.println("Physics done at Sprite: " + ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l));
			    }
			}

		    }

		}
	    }
	}
    }
    /**Does Collision between all Collidable Objects
     * @TODO Add Detection for Blocks(optional right now) and for Sprites in other Chunks that hang out and overlap with the current chunk.
     * 
     */
    private void doCollision(){
	//Right now, uses TEMP version of Collision detection. Will be improved later on.

	//Goes through sprites in Active Chunks and compares to other sprites in same chunk

	for(int i = 0; i < lvl.chunks.length; i++){//Row
	    for(int j = 0; j < lvl.chunks[0].length; j++){//Col
		if(lvl.chunks[i][j].isActive){//If Active
		    for(int k = 0; k < lvl.chunks[i][j].layers.size(); k++){//Layers
			if(lvl.chunks[i][j].layers.get(k) instanceof SpriteLayer){//SpriteLayer --Issue/NotReaching this code
			    for(int l = 0; l < ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.size(); l++){//Sprites
				if(((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l) instanceof Collidable){//If Collision

				    //System.out.println("FirstSprite: " + l + " " + ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l));

				    Rectangle hitbox1 = ((Collidable)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l)).getHitbox();
				    hitbox1.setLocation((int) ((j * lvl.chunks[i][j].getBlockSize()[1] * lvl.s.getSpriteSize()) + ((double) ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l).loc.x * lvl.s.getSpriteSize())) ,  (int) ((i * lvl.chunks[i][j].getBlockSize()[0] * lvl.s.getSpriteSize()) + ((double) ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l).loc.y * lvl.s.getSpriteSize())));//Calc Location in Pixels
				    //ChunkPosition.px + SpritePosition.px

				    //Checks for Collisions
				    for(int m = l+1; m < ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.size(); m++){//Checking Other Sprites

					//System.out.println(m);

					if(((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m) instanceof Collidable){
					    //System.out.println("Checking " + ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m));

					    Rectangle hitbox2 = ((Collidable)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m)).getHitbox();
					    hitbox2.setLocation((int) ((j * lvl.chunks[i][j].getBlockSize()[1] * lvl.s.getSpriteSize()) + ((double) ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m).loc.x * lvl.s.getSpriteSize())) ,  (int) ((i * lvl.chunks[i][j].getBlockSize()[0] * lvl.s.getSpriteSize()) + ((double) ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m).loc.y * lvl.s.getSpriteSize())));//Calc Location in Pixels

					    if(hitbox1.intersects(hitbox2)){
						//System.out.println("PossibleCollision| " + ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l) + "\t" + ((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m));
						((Collidable)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m)).doCollision((Collidable)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l));
						((Collidable)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(l)).doCollision((Collidable)((SpriteLayer)lvl.chunks[i][j].layers.get(k)).sprites.get(m));

					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }

	}

    }
}